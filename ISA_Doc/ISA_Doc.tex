\documentclass{article}

\usepackage[letterpaper,margin=0.5in,top=1in,bottom=1in]{geometry}

\usepackage{extramarks}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{tikz}
	\usetikzlibrary{positioning}
\usepackage[plain]{algorithm}
\usepackage{algpseudocode}
\usepackage{enumitem}
\usepackage{fancyhdr}
	\pagestyle{fancy}
	\lhead{\hmwkAuthorName}
	% \chead{\hmwkClass\ (\hmwkClassInstructor\ \hmwkClassTime): \hmwkTitle}
	\rhead{\firstxmark}
	\lfoot{\lastxmark}
	\cfoot{\thepage}

	\renewcommand{\headrulewidth}{0.4pt}
	\renewcommand{\footrulewidth}{0.4pt}
	\setlength{\headheight}{14.5pt}
\usepackage{fontspec}
	\setmainfont{Doulos SIL}
\usepackage{booktabs}
\usepackage{lscape}
\usepackage{longtable}
\usepackage{hyperref}

\setlength\parindent{0pt}

\newcommand{\hmwkTitle}{ISA Document}
\newcommand{\hmwkClass}{CSCI-453 Computer Architecture}
\newcommand{\hmwkAuthorName}{\textbf{Max Kipust, Drew Young}}

%
% Title Page
%

\title{
	\vspace{2in}
	\textmd{\textbf{\hmwkClass:\ \hmwkTitle}}\\
	\vspace{3in}
}

\author{\hmwkAuthorName}
\date{}

% \renewcommand{\part}[1]{\textbf{\large Part \Alph{partCounter}}\stepcounter{partCounter}\\}

%
% Various Helper Commands
%

% Useful for algorithms
\newcommand{\alg}[1]{\textsc{\bfseries \footnotesize #1}}

\begin{document}

\maketitle

\pagebreak

\section{Instruction Format}
	Instruction format, with a complete description of how the instructions will be encoded.

	We will have a fixed length instruction format. Each instruction will be 16 bits.
	We will have several instruction formats
	We will have multiple tables to look up the opcode so there are multiple opcode sections in our instruction formats.\\
	O = opcode(2 or 3 bits)\\
	B = belt position (3 bits)\\
	I = immediate value (8 bits)\\
	\begin{itemize}
		\item OBBI
		\item OOBI
		\item OOI
		\item OO
		\item OOBB
	\end{itemize}



	We will have several instruction formats,\\
	0 operand: halt, nop, return                            (0 belt, 0 imm)\\
	0 belt, 1 imm, 0 DAM, 0 CAM: const, readStack, alloca   (0 belt, 1 imm) *\\
	2 belt, 0 imm, 0 DAM, 0 CAM: ALU,                       (2 belt, 0 imm) *\\
	1 belt, 1 imm, 0 DAM, 0 CAM: ALU, writeStack            (1 belt, 1 imm) *\\
	0 belt, 0 imm, 1 DAM, 0 CAM: load                       (1 belt, 1 imm) *\\
	1 belt, 0 imm, 1 DAM, 0 CAM: store                      (2 belt, 1 imm) * \\
	1 belt, 0 imm, 0 DAM, 1 CAM: branch                     (1 belt, 1 imm) * \\
	0 belt, 0 imm, 0 DAM, 1 CAM: jump, call                 (0 belt, 1 imm) * 

	not every instruction follows this pattern. when the instruction format requires data that is not needed in the instruction. the extra data is ignored.

	% belt = 3 bits
	% opc = 4 bits
	% imm = 8 bits
	% |2  +  3 +  3 |   | 8|
	% |opc belt belt| |imm|

	% (0 belt, 0 imm) = 0 bits
	% (0 belt, 1 imm) = 16 bits
	% (2 belt, 0 imm) = 6 bits
	% (1 belt, 1 imm) = 19 bits
	% (2 belt, 1 imm) = 22 bits



	\subsection{Overview}
		We will have a fixed length instruction format.

	\subsection{opcode}
		We will have 3 tables to lookup the instruction for an opcode.
		The first table will have the store instruction and information on where to look for the next piece of the opcode.
		The next piece can either be put in the spot for the immediate value, or a belt index.


	\subsection{Address Modes}
		Description of all address modes supported, complete with how the address modes will be encoded

		2 address modes:
		\begin{itemize}
			\item data address mode: belt + imm
			\item code address mode: pc + imm
		\end{itemize}
		the data address mode is used for any instruction that uses data addresses (load, store), and the code address mode is used for any instruction that uses code addresses(branch, jump, call)

\clearpage
\begin{landscape}
\section{Instruction List}
	A list of all the instructions in your system, including opcode, the mnemonic, a description, and any information about encoding

	% \begin{tabular}{l l l l l l}
	% 	Instruction   & Opcode & Mnemonic & Description                                                             & Encoding        & Expected Cycles \\
	% 	\midrule
	% 	\multicolumn{5}{l}{\bfseries Misc} \\
	% 	Halt          & 0000   & HLT      & Halt the machine                                                        &                 & 1               \\
	% 	No op         & 0001   & NOP      & No operation                                                            &                 & 1               \\
	% 	\multicolumn{5}{l}{\bfseries ALU}                                                                                                       &                 \\
	% 	Add           & 0010   & ADD      & Add items at position a and b and add the result to belt                &                 & 1               \\
	% 	Subtract      & 0011   & SUB      & Subtract items at position a and b and add result to the belt           &                 & 1               \\
	% 	Multiply      & 0100   & MUL      & Multiple items at position a and b and add high and low values to belt  &                 & 5? idk          \\
	% 	\multicolumn{5}{l}{Memory}                                                                                                    &                 \\
	% 	Load          & 0110   & LDB      & Load from memory using address mode and put result onto belt            &                 & 8-16?           \\
	% 	Store         & 0111   & STB      & Store from position a and store into memory using address mode          &                 & 8-16?           \\
	% 	\multicolumn{5}{l}{Belt}                                                                                                      &                 \\
	% 	Push item     & 1001   & PUSH     & push the entire belt onto the stack                                     &                 &                 \\
	% 	Pop item      & 1010   & POP      & pop the entire belt onto the stack                                      &                 &                 \\
	% 	Load imm      &        & LOADI    & push immidiate value onto the belt                                      &                 &                 \\
	% 	\multicolumn{5}{l}{Control Flow}                                                                                              &                 \\
	% 	Branch if 0   & 1011   & BEZ      &                                                                         &                 &                 \\
	% 	jump 
	% 	Function Call & 1100   & CALL     & execute function using address mode, params are the belt                &                 &                 \\
	% 	Return        & 1101   & RET      & return from function, push a, b, c from old belt onto new belt          &                 &                 \\
	% 	% jump
	% 	              & 1110   &          &                                                                         &                 &                 \\
	% 	              & 1111   &          &                                                                         &                 &                
	% \end{tabular}

	\begin{longtable}{c c c c l l r l}
		Field 1 & Field 2 & Field 3 & Field 4 & Mnemonic & Description & Latency & RTL \\
		\midrule
		\texttt{00} & belt pos & belt pos & immediate & \texttt{store} & Store to memory \\

		\texttt{01} & belt pos & belt pos & \texttt{0000 0000} & \texttt{add}     & Add                    & 1 & \(
			\textrm{Belt} \gets B_1 + B_2\) \\
		\texttt{01} & belt pos & belt pos & \texttt{0000 0001} & \texttt{mul}     & Multiply               & 5 & \(
			\begin{array}{l}
				\textrm{Belt} \gets \left(B_1 \cdot B_2\right) << 16, \\
				\textrm{Belt} \gets B_1 \cdot B_2
			\end{array}\) \\
		\texttt{01} & belt pos & belt pos & \texttt{0000 0010} & \texttt{and}     & Bitwise and            & 1 & \(
			\textrm{Belt} \gets B_1 \mathop{\&} B_2\) \\
		\texttt{01} & belt pos & belt pos & \texttt{0000 0011} & \texttt{or}      & Bitwise or             & 1 & \(
			\textrm{Belt} \gets B_1 \mathop{|} B_2\) \\
		\texttt{01} & belt pos & belt pos & \texttt{0000 0100} & \texttt{xor}     & Bitwise exclusive or   & 1 & \(
			\textrm{Belt} \gets B_1 \oplus B_2\) \\
		\texttt{01} & belt pos & belt pos & \texttt{0000 0101} & \texttt{lshift}  & Left shift             & 1 & \(
			\textrm{Belt} \gets B_1 << B_2\) \\
		\texttt{01} & belt pos & belt pos & \texttt{0000 0110} & \texttt{rshift}  & Logical right shift    & 1 & \(
			\textrm{Belt} \gets B_1 >> B_2\) \\
		\texttt{01} & belt pos & belt pos & \texttt{0000 0111} & \texttt{arshift} & Arithmetic right shift & 1 & \(
			\textrm{Belt} \gets B_1 >>_a B_2\) \\
		\texttt{01} & belt pos & belt pos & \texttt{0000 1000} & \texttt{addc}    & Add carry              & 1 & \(
			\textrm{Belt} \gets B_1 + \operatorname{carry}\left(B_2\right)\) \\
		\texttt{01} & belt pos & belt pos & \texttt{0000 1001} & \texttt{sub}     & Subtract               & 1 & \(
			\textrm{Belt} \gets B_1 - B_2\) \\
		\texttt{01} & belt pos & belt pos & \texttt{0000 1010} & \texttt{subc}    & Subtract carry         & 1 & \(
			\textrm{Belt} \gets \overline{B_1} + \operatorname{carry}\left(B_2\right)\) \\
		\texttt{01} & & & \texttt{0000 1011} & INVALID & & \\
								& & & \(\vdots\)         &         & & \\
		\texttt{01} & & & \texttt{1111 1110} & INVALID & & \\
		\texttt{01} & belt pos & \texttt{000} & \texttt{1111 1111} & \texttt{invert}     & Bitwise inversion              & 1   & \(
			\textrm{Belt} \gets \overline{B_1}\) \\
		\texttt{01} & belt pos & \texttt{001} & \texttt{1111 1111} & \texttt{negate}     & Numeric negation               & 1   & \(
			\textrm{Belt} \gets -B_1\) \\
		\texttt{01} & belt pos & \texttt{010} & \texttt{1111 1111} & \texttt{longcall}   & Call function from belt        & N/A & \(
			\begin{array}{l}
				\textrm{Mem}\left[\textrm{SP}\right] \gets \textrm{FP}, \\
				\textrm{Mem}\left[\textrm{SP} + 1\right] \gets \textrm{PC} + 1, \\
				\textrm{PC} \gets B_1, \\
				\textrm{FP} \gets \textrm{SP} + 2 \\
			\end{array}\) \\
		\texttt{01} & belt pos & \texttt{011} & \texttt{1111 1111} & \texttt{longjump}   & Unconditional branch from belt & N/A & \(
			\textrm{PC} \gets B_1\) \\
		\texttt{01} & belt pos & \texttt{100} & \texttt{1111 1111} & \texttt{get\_carry} & Retrieve carry metadata        & 1   & \(
			\textrm{Belt} \gets \operatorname{carry}\left(B_1\right)\) \\
		\texttt{01} & & \texttt{101} & \texttt{1111 1111} & INVALID & \\
		\texttt{01} & & \texttt{110} & \texttt{1111 1111} & INVALID & \\
		\texttt{01} & \texttt{000} & \texttt{111} & \texttt{1111 1111} & \texttt{halt}    & Halt the computer                    & N/A & HALT \\
		\texttt{01} & \texttt{001} & \texttt{111} & \texttt{1111 1111} & \texttt{nop}     & No operation                         & N/A & \\
		\texttt{01} & \texttt{010} & \texttt{111} & \texttt{1111 1111} & \texttt{return}  & Return from function                 & N/A & \(
			\begin{array}{l}
				\textrm{PC} \gets \textrm{Mem}\left[\textrm{FP} - 1\right], \\
				\textrm{FP} \gets \textrm{Mem}\left[\textrm{FP} - 2\right], \\
				\textrm{SP} \gets \textrm{FP} - 2 \\
			\end{array}\) \\
		\texttt{01} & \texttt{011} & \texttt{111} & \texttt{1111 1111} & \texttt{get\_pc} & Retrieve the current program counter & 1   & \(
			\textrm{Belt} \gets \textrm{PC}\) \\
		\texttt{01} & \texttt{100} & \texttt{111} & \texttt{1111 1111} & INVALID & \\
		            & \(\vdots\)   &              &                    &         & \\
		\texttt{01} & \texttt{111} & \texttt{111} & \texttt{1111 1111} & INVALID & \\

		\texttt{10} & belt pos & \texttt{000} & immediate & \texttt{addi}     & Add with immediate                    & 1 & \(
			\textrm{Belt} \gets B_1 + \operatorname{sign\_ext}\left(\textrm{Imm}\right)\) \\
		\texttt{10} & belt pos & \texttt{001} & immediate & \texttt{muli}     & Multiply with immediate               & 5 & \(
			\textrm{Belt} \gets B_1 \cdot \operatorname{sign\_ext}\left(\textrm{Imm}\right)\) \\
		\texttt{10} & belt pos & \texttt{010} & immediate & \texttt{andi}     & Bitwise and with immediate            & 1 & \(
			\textrm{Belt} \gets B_1 \mathop{\&} \operatorname{sign\_ext}\left(\textrm{Imm}\right)\) \\
		\texttt{10} & belt pos & \texttt{011} & immediate & \texttt{ori}      & Bitwise or with immediate             & 1 & \(
			\textrm{Belt} \gets B_1 \mathop{|} \textrm{Imm}\) \\
		\texttt{10} & belt pos & \texttt{100} & immediate & \texttt{xori}     & Bitwise exclusive or with immediate   & 1 & \(
			\textrm{Belt} \gets B_1 \oplus \textrm{Imm}\) \\
		\texttt{10} & belt pos & \texttt{101} & immediate & \texttt{lshifti}  & Left shift with immediate             & 1 & \(
			\textrm{Belt} \gets B_1 << \textrm{Imm}\) \\
		\texttt{10} & belt pos & \texttt{110} & immediate & \texttt{rshifti}  & Logical right shift with immediate    & 1 & \(
			\textrm{Belt} \gets B_1 >> \textrm{Imm}\) \\
		\texttt{10} & belt pos & \texttt{111} & immediate & \texttt{arshifti} & Arithmetic right shift with immediate & 1 & \(
			\textrm{Belt} \gets B_1 >>_a \textrm{Imm}\) \\

		\texttt{11} & belt pos & \texttt{000} & immediate & \texttt{branch\_zero}  & Branch if zero          & N/A & TODO \\
		\texttt{11} & belt pos & \texttt{001} & immediate & \texttt{branch\_neg}   & Branch if negative      & N/A & TODO \\
		\texttt{11} & belt pos & \texttt{010} & immediate & \texttt{branch\_oflow} & Branch on overflow      & N/A & TODO \\
		\texttt{11} & belt pos & \texttt{011} & immediate & \texttt{branch\_carry} & Branch on carry         & N/A & TODO \\
		\texttt{11} & belt pos & \texttt{100} & immediate & \texttt{write\_stack}  & Write to stack position & N/A & \(
			\textrm{Mem}\left[\textrm{FP} + \operatorname{sign\_ext}\left(\textrm{Imm}\right)\right] \gets B_1\) \\
		\texttt{11} & belt pos & \texttt{101} & immediate & \texttt{load}          & Load from memory        & 1   & \(
			\textrm{Belt} \gets \textrm{Mem}\left[B_1 + \operatorname{sign\_ext}\left(\textrm{Imm}\right)\right]\) \\
		\texttt{11} & & \texttt{110} & & INVALID & \\
		\texttt{11} & \texttt{000} & \texttt{111} & immediate & \texttt{constant}    & Load immediate           & 1   & \(
			\textrm{Belt} \gets \operatorname{sign\_ext}\left(\textrm{Imm}\right)\) \\
		\texttt{11} & \texttt{001} & \texttt{111} & immediate & \texttt{upper}       & Load upper immediate     & 1   & \(
			\textrm{Belt} \gets \textrm{Imm} << 8\) \\
		\texttt{11} & \texttt{010} & \texttt{111} & immediate & \texttt{call}        & Call function            & N/A & \(
			\begin{array}{l}
				\textrm{Mem}\left[\textrm{SP}\right] \gets \textrm{FP}, \\
				\textrm{Mem}\left[\textrm{SP} + 1\right] \gets \textrm{PC} + 1, \\
				\textrm{PC} \gets \textrm{PC} + \operatorname{sign\_ext}\left(\textrm{Imm}\right), \\
				\textrm{FP} \gets \textrm{SP} + 2 \\
			\end{array}\) \\
		\texttt{11} & \texttt{011} & \texttt{111} & immediate & \texttt{jump}        & Unconditional branch     & N/A & \(
			\textrm{PC} \gets \textrm{PC} + \operatorname{sign\_ext}\left(\textrm{Imm}\right)\) \\
		\texttt{11} & \texttt{100} & \texttt{111} & immediate & \texttt{read\_stack} & Read from stack position & 1   & \(
			\textrm{Belt} \gets \textrm{Mem}\left[\textrm{FP} + \textrm{Imm}\right]\) \\
		\texttt{11} & \texttt{101} & \texttt{111} & immediate & \texttt{alloca}      & Allocate stack space     & N/A & \(
			\textrm{SP} \gets \textrm{SP} + \textrm{Imm}\) \\
		\texttt{11} & \texttt{110} & \texttt{111} & & INVALID & \\
		\texttt{11} & \texttt{111} & \texttt{111} & & INVALID & \\
	\end{longtable}
\end{landscape}

\section{Memory Space}
	Information about the memory space, address size, bits-per-addressable-unit, width of the bus to memory (how many units get transfered per load/store)
	Our Address will be N bits and our data will be M bits.
	Each address will be able to access M bits from memory.
	We will be transfering a single item to and from memory with load and store\\
	We may just use that for push belt and pop belt, or we can allow memory to take up to 8*M bits at once to write

\section{Program Visible Registers}
	Name and description of all the program visible registers\\
	We don't have any program visible registers? do we want to make the stack visible? 



\end{document}
