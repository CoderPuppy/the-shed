\documentclass{article}

\usepackage{fancyhdr}
\usepackage{extramarks}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{tikz}
\usepackage[plain]{algorithm}
\usepackage{algpseudocode}
\usepackage{enumitem}


\usetikzlibrary{automata,positioning}

%
% Basic Document Settings
%

\topmargin=-0.45in
\evensidemargin=0in
\oddsidemargin=0in
\textwidth=6.5in
\textheight=9.0in
\headsep=0.25in

\usepackage{fontspec}
\setmainfont{Doulos SIL}

\linespread{1.1}

\pagestyle{fancy}
\lhead{\hmwkAuthorName}
% \chead{\hmwkClass\ (\hmwkClassInstructor\ \hmwkClassTime): \hmwkTitle}
\rhead{\firstxmark}
\lfoot{\lastxmark}
\cfoot{\thepage}

\renewcommand\headrulewidth{0.4pt}
\renewcommand\footrulewidth{0.4pt}

\setlength\parindent{0pt}

%
% Create Problem Sections
%

% \newcommand{\enterProblemHeader}[1]{
%     \nobreak\extramarks{}{Problem \arabic{#1} continued on next page\ldots}\nobreak{}
%     \nobreak\extramarks{Problem \arabic{#1} (continued)}{Problem \arabic{#1} continued on next page\ldots}\nobreak{}
% }

% \newcommand{\exitProblemHeader}[1]{
%     \nobreak\extramarks{Problem \arabic{#1} (continued)}{Problem \arabic{#1} continued on next page\ldots}\nobreak{}
%     \stepcounter{#1}
%     \nobreak\extramarks{Problem \arabic{#1}}{}\nobreak{}
% }

% \setcounter{secnumdepth}{0}
% \newcounter{partCounter}
% \newcounter{homeworkProblemCounter}
% \setcounter{homeworkProblemCounter}{1}
% \nobreak\extramarks{Problem \arabic{homeworkProblemCounter}}{}\nobreak{}

%
% Homework Problem Environment
%
% This environment takes an optional argument. When given, it will adjust the
% problem counter. This is useful for when the problems given for your
% assignment aren't sequential. See the last 3 problems of this template for an
% example.
%
% \newenvironment{homeworkProblem}[1][-1]{
%     \ifnum#1>0
%         \setcounter{homeworkProblemCounter}{#1}
%     \fi
%     \section{Problem \arabic{homeworkProblemCounter}}
%     \setcounter{partCounter}{1}
%     \enterProblemHeader{homeworkProblemCounter}
% }{
%     \exitProblemHeader{homeworkProblemCounter}
% }

%
% Homework Details
%   - Title
%   - Due date
%   - Class
%   - Section/Time
%   - Instructor
%   - Author
%

\newcommand{\hmwkTitle}{ISA Document}
\newcommand{\hmwkClass}{CSCI-453 Computer Architecture}
\newcommand{\hmwkAuthorName}{\textbf{Max Kipust, Drew Young}}

%
% Title Page
%

\title{
    \vspace{2in}
    \textmd{\textbf{\hmwkClass:\ \hmwkTitle}}\\
    \vspace{3in}
}

\author{\hmwkAuthorName}
\date{}

% \renewcommand{\part}[1]{\textbf{\large Part \Alph{partCounter}}\stepcounter{partCounter}\\}

%
% Various Helper Commands
%

% Useful for algorithms
\newcommand{\alg}[1]{\textsc{\bfseries \footnotesize #1}}

% For derivatives
\newcommand{\deriv}[1]{\frac{\mathrm{d}}{\mathrm{d}x} (#1)}

% For partial derivatives
\newcommand{\pderiv}[2]{\frac{\partial}{\partial #1} (#2)}

% Integral dx
\newcommand{\dx}{\mathrm{d}x}

% Alias for the Solution section header
\newcommand{\solution}{\textbf{\large Solution}}

% Probability commands: Expectation, Variance, Covariance, Bias
\newcommand{\E}{\mathrm{E}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\Bias}{\mathrm{Bias}}

\begin{document}

\maketitle

\pagebreak

\section{Instruction Format}
Instruction format, with a complete description of how the instructions will be encoded.

0 operand: halt, nop, return                            (0 belt, 0 imm)
0 belt, 1 imm, 0 DAM, 0 CAM: const, readStack, alloca   (0 belt, 1 imm)
2 belt, 0 imm, 0 DAM, 0 CAM: ALU,                       (2 belt, 0 imm)
1 belt, 1 imm, 0 DAM, 0 CAM: ALU, writeStack            (1 belt, 1 imm)
0 belt, 0 imm, 1 DAM, 0 CAM: load                       (1 belt, 1 imm)
1 belt, 0 imm, 1 DAM, 0 CAM: store                      (2 belt, 1 imm)
1 belt, 0 imm, 0 DAM, 1 CAM: branch                     (1 belt, 1 imm)
0 belt, 0 imm, 0 DAM, 1 CAM: jump, call                 (0 belt, 1 imm)

belt = 4 bits
opc = 4 bits
imm = 32 bits
|  4+   4+   4| | 32|
|opc belt belt| |imm|

(0 belt, 0 imm) = 0 bits
(0 belt, 1 imm) = 32 bits
(2 belt, 0 imm) = 8 bits
(1 belt, 1 imm) = 36 bits
(2 belt, 1 imm) = 40 bits


\subsection{Overview}
We will have a fixed length instruction format.
\subsection{opcode}
We will have 16 opcodes, 5 bits. See Instruction List.
\subsection{Address Modes}
We will have N address modes.
Each address mode will only be used to generate an effective address and can only be used in instructions that access memory.


\section{Instruction List}
A list of all the instructions in your system, including opcode, the mnemonic, a description, and any information about encoding

We should specify which AM each instruction useses (if any)
    \begin{tabular}{llllll}
    Instruction   & Opcode & Mnemonic & Description                                                             & Encoding                                                              & Expected Cycles \\
    \multicolumn{5}{l}{Misc}                                                                                                                                                            &                 \\
    Halt          & 0000   & HLT      & Halt the machine                                                        &                                                                       & 1               \\
    No op         & 0001   & NOP      & No operation                                                            &                                                                       & 1               \\
    \multicolumn{5}{l}{ALU}                                                                                                                                                             &                 \\
    Add           & 0010   & ADD      & Add items at position a and b and add the result to belt                &                                                                       & 1               \\
    Subtract      & 0011   & SUB      & Subtract items at position a and b and add result to the belt           &                                                                       & 1               \\
    Multiply      & 0100   & MUL      & Multiple items at position a and b and add high and low values to belt  &                                                                       & 5? idk          \\
    % Divide        & 0101   & DIV      & Divide items at position a and b and add quotient and remainder to belt &                                                                       & 10? idk         \\
    \multicolumn{5}{l}{Memory}                                                                                                                                                          &                 \\
    Load          & 0110   & LDB      & Load from memory using address mode and put result onto belt            &                                                                       & 8-16?           \\
    Store         & 0111   & STB      & Store from position a and store into memory using address mode          &                                                                       & 8-16?           \\
    \multicolumn{5}{l}{Belt}                                                                                                                                                            &                 \\
    % Duplicate     & 1000   & DUP      & copy item on the belt                                                   & Do we need this? or do we just want to do add 0                       &                 \\
    Push item     & 1001   & PUSH     & push the entire belt onto the stack                                     &                                                                       &                 \\
    Pop item      & 1010   & POP      & pop the entire belt onto the stack                                      &                                                                       &                 \\
    Load imm      &        & LOADI    & push immidiate value onto the belt                                      &                                                                       &                 \\
    \multicolumn{5}{l}{Control Flow}                                                                                                                                                    &                 \\
    Branch if 0   & 1011   & BEZ      &                                                                         &                                                                       &                 \\
    jump 
    Function Call & 1100   & CALL     & execute function using address mode, params are the belt                & Do we need this? isn't this just push belt, push return val, and jump &                 \\
    Return        & 1101   & RET      & return from function, push a, b, c from old belt onto new belt          & pop return val, pop belt, push return data                            &                 \\
                  & 1110   &          &                                                                         &                                                                       &                 \\
                  & 1111   &          &                                                                         &                                                                       &                
    \end{tabular}

\section{Memory Space}
Information about the memory space, address size, bits-per-addressable-unit, width of the bus to memory (how many units get transfered per load/store)
Our Address will be N bits and our data will be M bits.
Each address will be able to access M bits from memory.
We will be transfering a single item to and from memory with load and store\\
We may just use that for push belt and pop belt, or we can allow memory to take up to 8*M bits at once to write

\section{Program Visible Registers}
Name and description of all the program visible registers\\
We don't have any program visible registers? do we want to make the stack visible? 

\section{Address Modes}
Description of all address modes supported, complete with how the address modes will be encoded

The mill has base, index and offset. that seems easy enough to do

2 address modes:
    data address mode: belt + imm
    code address mode: pc + imm


\end{document}